define(
  'ephox.mediator.util.Prop',

  [
    'ephox.compass.Arr',
    'ephox.compass.Obj',
    'ephox.highway.Merger',
    'ephox.numerosity.api.JSON',
    'ephox.peanut.Fun',
    'ephox.perhaps.Option',
    'ephox.perhaps.Result',
    'ephox.scullion.ADT',
    'global!Error'
  ],

  function (Arr, Obj, Merger, Json, Fun, Option, Result, Adt, Error) {
    // FIX: Taken from lab.

    
    var read = function (key) {
      return function (obj) {
        return Option.from(obj[key]);
      };
    };

    var wrap = function (key, value) {
      var r = {};
      r[key] = value;
      return r;
    };

    var wrapAll = function (keyvalues) {
      var r = {};
      Arr.each(keyvalues, function (kv) {
        r[kv.key] = kv.value;
      });
      return r;
    };

    var readOr = function (key, fallback) {
      return function (obj) {
        return read(key)(obj).getOr(fallback);
      };
    };

    var readFrom = function (obj, key) {
      return read(key)(obj);
    };

    var narrow = function (obj, fields) {
      var r = { };
      Arr.each(fields, function (field) {
        if (obj[field] !== undefined) r[field] = obj[field];
      });

      return r;
    };

    var consolidate = function (objects, base) {
      return Arr.foldl(objects, function (acc, obj) {
        return acc.fold(function (accErrs) {
          return obj.fold(function (errs) {
            return Result.error(accErrs.concat(errs));
          }, function (_) {
            return Result.error(accErrs);
          }) ; 
        }, function (accRest) {
          return obj.fold(function (errs) {
            return Result.error(errs);
          }, function (v) {
            return Result.value(Merger.deepMerge(accRest, v));
          });
        });
      }, Result.value(base));
    };

    var consolidateArr = function (objects) {
      return Arr.foldl(objects, function (acc, obj) {
        return acc.fold(function (accErrs) {
          return obj.fold(function (errs) {
            return Result.error(accErrs.concat(errs));
          }, function (_) {
            return Result.error(accErrs);
          }) ; 
        }, function (accRest) {
          return obj.fold(function (errs) {
            return Result.error(errs);
          }, function (v) {
            return Result.value([ v ].concat(accRest));
          });
        });
      }, Result.value([ ]));
    };

    var doExtract = function (path, readerTypes, f, obj) {
      var readValues = Arr.map(readerTypes, function (rt) {
        return rt.fold(function (okey, value) {
          // output
          return Result.value(wrap(okey, f(value)));
        }, function (key, okey) {
          // strict
          return readFrom(obj, key).fold(function () {
            return Result.error([ 'Path: ' + path.join(' > ') + '\nCould not find valid value for "' + key + '" in ' + Json.stringify(obj, null, 2) ]);
          }, function (v) {
            return Result.value(wrap(okey, f(v)));
          });
          
        }, function (key, okey, fallback) {
          // withDefault
          var value = readFrom(obj, key).getOr(fallback);
          return Result.value(wrap(okey, f(value)));
        }, function (key, okey) {
          // asOption
          var value = readFrom(obj, key);
          return Result.value(wrap(okey, f(value)));
        }, function (key, okey, children) {
          // strict group
          return readFrom(obj, key).fold(function () {
            return Result.error([
              'Path: ' + path.join(' > ') + '\nCould not find valid value for "' + key + '" in ' + Json.stringify(obj, null, 2)
            ]);
          }, function (groupData) {
            var group = doExtract(path.concat([ key ]), children, f, groupData);
            return group.map(function (g) {
              return wrap(okey, f(g));  
            });
          });
        }, function (key, okey, children, fallback) {
          // default group
          var groupData = readFrom(obj, key).getOr(fallback);
          var group = doExtract(path.concat([ key ]), children, f, groupData);
          return group.map(function (g) {
            return wrap(okey, f(g));
          });
        }, function (key, okey, children, ifTrue) {
          // option group
          var groupData = obj[key] === undefined || obj[key] === false ? Option.none() : Option.some(obj[key] === true ? ifTrue : obj[key]);
          return groupData.fold(function () {
            return Result.value(wrap(okey, f(Option.none())));
          }, function (gd) {
            return doExtract(path.concat([ key ]), children, f, gd).map(function (group) {
              return wrap(okey, f(Option.some(group)));
            });
          });
        },

        function (key, okey, props) {
          // strict array
          return readFrom(obj, key).fold(function () {
            return Result.error([
              'Path: ' + path.join(' > ') + '\nCould not find valid value for "' + key + '" in ' + Json.stringify(obj, null, 2)
            ]);
          }, function (arrayData) {
            // Probably will need to concat this.
            var extracted = Arr.map(arrayData, function (x, i) {
              return doExtract(path.concat([ key + '[' + i + ']' ]), props, f, x);
            });

            var consolidated = consolidateArr(extracted, {});
            return consolidated.map(function (c) {
              return wrap(okey, c);
            });

            console.log('extracted', extracted, consolidate(extracted, {}));
          });
        },

        function (key, okey, props, fallback) {
          // default array
          return Result.error('defaultArray Not implemented');

        },

        function (key, okey, pops) {
          //option array
          return Result.error('optionArray Not implemented');

        }, function (okey, constructor) {
          // state
          var state = constructor();
          return Result.value(wrap(okey, f(state)));
        }, function (g) {
          // custom
          return f(g(obj));
        }, function (okey) {
          return Result.value(wrap(okey, f(obj)));
        });
      });
      return consolidate(readValues, { });
    };

    var extractReader = function (path, readerTypes, wrapping) {
      return function (obj) {
        var extracted = doExtract(path, readerTypes, wrapping, obj);
        return extracted.fold(function (errs) {
          throw new Error('Invalid attempt to read: ' + Json.stringify(obj) + '.\n' + errs.join('\n'));
        }, Fun.identity);
      };
    };

    var weak = function (path, readerTypes) {
      return extractReader(path, readerTypes, Fun.identity);
    };

    var extract = function (path, readerTypes) {
      return extractReader(path, readerTypes, Fun.constant);
    };

    var readers = Adt.generate([
      { output: [ 'okey', 'value' ] },
      { strict: [ 'key', 'okey' ] },
      { withDefault: [ 'key', 'okey', 'fallback' ] },
      { asOption: [ 'key', 'okey' ] },
      { asStrictGroup: [ 'key', 'okey', 'children' ] },
      { asDefaultGroup: [ 'key', 'okey', 'children', 'fallback' ] },
      { asOptionGroup: [ 'key', 'okey', 'children', 'ifTrue' ] },

      // <ADDED>
      { asStrictArray: [ 'key', 'okey', 'props' ]},
      { asDefaultArray: [ 'key', 'okey', 'props', 'fallback' ] },
      { asOptionArray: [ 'key', 'okey', 'props' ]},

      // </ADDED>

      { state: [ 'okey', 'constructor' ] },
      { custom : [ 'f' ] },
      { snapshot: [ 'okey' ]}
    ]);

    return {
      read: read,
      readOr: readOr,
      readFrom: readFrom,
      narrow: narrow,

      extract: extract,
      weak: weak,

      output: readers.output,
      strict: readers.strict,
      withDefault: readers.withDefault,
      asOption: readers.asOption,
      
      asStrictGroup: readers.asStrictGroup,
      asDefaultGroup: readers.asDefaultGroup,
      asOptionGroup: readers.asOptionGroup,
      
      strictArray: readers.asStrictArray,
      defaultArray: readers.asDefaultArray,
      optionArray: readers.asOptionArray,

      state: readers.state,
      snapshot: readers.snapshot,

      consolidate: consolidate,

      wrap: wrap,
      wrapAll: wrapAll
    };
  }
);